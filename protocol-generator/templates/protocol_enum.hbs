{{~#if packets}}
pub enum {{protocol_enum_name}} {
{{~#each packets as |p|}}
    {{p.name}}{{#if p.fields}}({{p.name}}){{/if}},
{{~/each}}
}

impl {{protocol_enum_name}} {
    pub fn get_type_id(&self) -> u8 {
        match self {
        {{~#each packets as |p|}}
            Self::{{p.name}}{{#if p.fields}}(_){{/if}} => {{packet_id p.id}},
        {{~/each}}
        }
    }

    pub fn decode<R: Read>(type_id: u8, reader: &mut R) -> Result<Self, DecodeError> {
        match type_id {
        {{~#each packets as |p|}}
            {{packet_id p.id}} => {
            {{~#if p.fields}}
                let {{snake_case p.name}} = {{p.name}}::decode(reader)?;

                Ok(Self::{{p.name}}({{snake_case p.name}}))
            {{~/if}}
            {{~#unless p.fields}}
                Ok(Self::{{p.name}})
            {{~/unless}}
            }
        {{~/each}}
            _ => Err(DecodeError::UnknownPacketType { type_id })
        }
    }
{{#each packets as |p|}}
    pub fn {{snake_case p.name}}({{~#each p.fields as |f|}}{{f.name}}: {{#if (ne f.type "RefType")}}{{f.type}}{{~else}}{{f.ref_name}}{{/if}}{{#unless @last}}, {{/unless}}{{~/each}}) -> Self {
    {{~#if p.fields}}
        let {{snake_case p.name}} = {{p.name}} {
        {{~#each p.fields as |f|}}
            {{f.name}},
        {{~/each}}
        };

        Self::{{p.name}}({{snake_case p.name}})
    {{~/if}}
    {{~#unless p.fields}}
        Self::{{p.name}}
    {{~/unless}}
    }
{{/each~}}
}
{{~/if}}
