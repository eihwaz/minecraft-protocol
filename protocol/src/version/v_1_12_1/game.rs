// This file is automatically generated.
// It is not intended for manual editing.
use crate::DecodeError;
use crate::Decoder;
use minecraft_protocol_derive::Packet;
use std::io::Read;

use crate::data::game::*;
use nbt::CompoundTag;
use uuid::Uuid;

pub enum ServerBoundGamePacket {
    TeleportConfirm(TeleportConfirm),
    ServerBoundTabComplete(ServerBoundTabComplete),
    ServerBoundChat(ServerBoundChat),
    ClientCommand(ClientCommand),
    Settings(Settings),
    ServerBoundTransaction(ServerBoundTransaction),
    EnchantItem(EnchantItem),
    WindowClick(WindowClick),
    ServerBoundCloseWindow(ServerBoundCloseWindow),
    ServerBoundCustomPayload(ServerBoundCustomPayload),
    UseEntity(UseEntity),
    ServerBoundKeepAlive(ServerBoundKeepAlive),
    ServerBoundPosition(ServerBoundPosition),
    PositionLook(PositionLook),
    Look(Look),
    Flying(Flying),
    ServerBoundVehicleMove(ServerBoundVehicleMove),
    SteerBoat(SteerBoat),
    CraftRecipeRequest(CraftRecipeRequest),
    ServerBoundAbilities(ServerBoundAbilities),
    BlockDig(BlockDig),
    EntityAction(EntityAction),
    SteerVehicle(SteerVehicle),
    CraftingBookData(CraftingBookData),
    ResourcePackReceive(ResourcePackReceive),
    ServerBoundHeldItemSlot(ServerBoundHeldItemSlot),
    SetCreativeSlot(SetCreativeSlot),
    UpdateSign(UpdateSign),
    ArmAnimation(ArmAnimation),
    Spectate(Spectate),
    BlockPlace(BlockPlace),
    UseItem(UseItem),
    AdvancementTab(AdvancementTab),
}

impl ServerBoundGamePacket {
    pub fn get_type_id(&self) -> u8 {
        match self {
            Self::TeleportConfirm(_) => 0x00,
            Self::ServerBoundTabComplete(_) => 0x01,
            Self::ServerBoundChat(_) => 0x02,
            Self::ClientCommand(_) => 0x03,
            Self::Settings(_) => 0x04,
            Self::ServerBoundTransaction(_) => 0x05,
            Self::EnchantItem(_) => 0x06,
            Self::WindowClick(_) => 0x07,
            Self::ServerBoundCloseWindow(_) => 0x08,
            Self::ServerBoundCustomPayload(_) => 0x09,
            Self::UseEntity(_) => 0x0A,
            Self::ServerBoundKeepAlive(_) => 0x0B,
            Self::ServerBoundPosition(_) => 0x0D,
            Self::PositionLook(_) => 0x0E,
            Self::Look(_) => 0x0F,
            Self::Flying(_) => 0x0C,
            Self::ServerBoundVehicleMove(_) => 0x10,
            Self::SteerBoat(_) => 0x11,
            Self::CraftRecipeRequest(_) => 0x12,
            Self::ServerBoundAbilities(_) => 0x13,
            Self::BlockDig(_) => 0x14,
            Self::EntityAction(_) => 0x15,
            Self::SteerVehicle(_) => 0x16,
            Self::CraftingBookData(_) => 0x17,
            Self::ResourcePackReceive(_) => 0x18,
            Self::ServerBoundHeldItemSlot(_) => 0x1A,
            Self::SetCreativeSlot(_) => 0x1B,
            Self::UpdateSign(_) => 0x1C,
            Self::ArmAnimation(_) => 0x1D,
            Self::Spectate(_) => 0x1E,
            Self::BlockPlace(_) => 0x1F,
            Self::UseItem(_) => 0x20,
            Self::AdvancementTab(_) => 0x19,
        }
    }

    pub fn decode<R: Read>(type_id: u8, reader: &mut R) -> Result<Self, DecodeError> {
        match type_id {
            0x00 => {
                let teleport_confirm = TeleportConfirm::decode(reader)?;

                Ok(Self::TeleportConfirm(teleport_confirm))
            }
            0x01 => {
                let server_bound_tab_complete = ServerBoundTabComplete::decode(reader)?;

                Ok(Self::ServerBoundTabComplete(server_bound_tab_complete))
            }
            0x02 => {
                let server_bound_chat = ServerBoundChat::decode(reader)?;

                Ok(Self::ServerBoundChat(server_bound_chat))
            }
            0x03 => {
                let client_command = ClientCommand::decode(reader)?;

                Ok(Self::ClientCommand(client_command))
            }
            0x04 => {
                let settings = Settings::decode(reader)?;

                Ok(Self::Settings(settings))
            }
            0x05 => {
                let server_bound_transaction = ServerBoundTransaction::decode(reader)?;

                Ok(Self::ServerBoundTransaction(server_bound_transaction))
            }
            0x06 => {
                let enchant_item = EnchantItem::decode(reader)?;

                Ok(Self::EnchantItem(enchant_item))
            }
            0x07 => {
                let window_click = WindowClick::decode(reader)?;

                Ok(Self::WindowClick(window_click))
            }
            0x08 => {
                let server_bound_close_window = ServerBoundCloseWindow::decode(reader)?;

                Ok(Self::ServerBoundCloseWindow(server_bound_close_window))
            }
            0x09 => {
                let server_bound_custom_payload = ServerBoundCustomPayload::decode(reader)?;

                Ok(Self::ServerBoundCustomPayload(server_bound_custom_payload))
            }
            0x0A => {
                let use_entity = UseEntity::decode(reader)?;

                Ok(Self::UseEntity(use_entity))
            }
            0x0B => {
                let server_bound_keep_alive = ServerBoundKeepAlive::decode(reader)?;

                Ok(Self::ServerBoundKeepAlive(server_bound_keep_alive))
            }
            0x0D => {
                let server_bound_position = ServerBoundPosition::decode(reader)?;

                Ok(Self::ServerBoundPosition(server_bound_position))
            }
            0x0E => {
                let position_look = PositionLook::decode(reader)?;

                Ok(Self::PositionLook(position_look))
            }
            0x0F => {
                let look = Look::decode(reader)?;

                Ok(Self::Look(look))
            }
            0x0C => {
                let flying = Flying::decode(reader)?;

                Ok(Self::Flying(flying))
            }
            0x10 => {
                let server_bound_vehicle_move = ServerBoundVehicleMove::decode(reader)?;

                Ok(Self::ServerBoundVehicleMove(server_bound_vehicle_move))
            }
            0x11 => {
                let steer_boat = SteerBoat::decode(reader)?;

                Ok(Self::SteerBoat(steer_boat))
            }
            0x12 => {
                let craft_recipe_request = CraftRecipeRequest::decode(reader)?;

                Ok(Self::CraftRecipeRequest(craft_recipe_request))
            }
            0x13 => {
                let server_bound_abilities = ServerBoundAbilities::decode(reader)?;

                Ok(Self::ServerBoundAbilities(server_bound_abilities))
            }
            0x14 => {
                let block_dig = BlockDig::decode(reader)?;

                Ok(Self::BlockDig(block_dig))
            }
            0x15 => {
                let entity_action = EntityAction::decode(reader)?;

                Ok(Self::EntityAction(entity_action))
            }
            0x16 => {
                let steer_vehicle = SteerVehicle::decode(reader)?;

                Ok(Self::SteerVehicle(steer_vehicle))
            }
            0x17 => {
                let crafting_book_data = CraftingBookData::decode(reader)?;

                Ok(Self::CraftingBookData(crafting_book_data))
            }
            0x18 => {
                let resource_pack_receive = ResourcePackReceive::decode(reader)?;

                Ok(Self::ResourcePackReceive(resource_pack_receive))
            }
            0x1A => {
                let server_bound_held_item_slot = ServerBoundHeldItemSlot::decode(reader)?;

                Ok(Self::ServerBoundHeldItemSlot(server_bound_held_item_slot))
            }
            0x1B => {
                let set_creative_slot = SetCreativeSlot::decode(reader)?;

                Ok(Self::SetCreativeSlot(set_creative_slot))
            }
            0x1C => {
                let update_sign = UpdateSign::decode(reader)?;

                Ok(Self::UpdateSign(update_sign))
            }
            0x1D => {
                let arm_animation = ArmAnimation::decode(reader)?;

                Ok(Self::ArmAnimation(arm_animation))
            }
            0x1E => {
                let spectate = Spectate::decode(reader)?;

                Ok(Self::Spectate(spectate))
            }
            0x1F => {
                let block_place = BlockPlace::decode(reader)?;

                Ok(Self::BlockPlace(block_place))
            }
            0x20 => {
                let use_item = UseItem::decode(reader)?;

                Ok(Self::UseItem(use_item))
            }
            0x19 => {
                let advancement_tab = AdvancementTab::decode(reader)?;

                Ok(Self::AdvancementTab(advancement_tab))
            }
            _ => Err(DecodeError::UnknownPacketType { type_id }),
        }
    }

    pub fn teleport_confirm(teleport_id: i32) -> Self {
        let teleport_confirm = TeleportConfirm { teleport_id };

        Self::TeleportConfirm(teleport_confirm)
    }

    pub fn server_bound_tab_complete(
        text: String,
        assume_command: bool,
        looked_at_block: Position,
    ) -> Self {
        let server_bound_tab_complete = ServerBoundTabComplete {
            text,
            assume_command,
            looked_at_block,
        };

        Self::ServerBoundTabComplete(server_bound_tab_complete)
    }

    pub fn server_bound_chat(message: String) -> Self {
        let server_bound_chat = ServerBoundChat { message };

        Self::ServerBoundChat(server_bound_chat)
    }

    pub fn client_command(action_id: i32) -> Self {
        let client_command = ClientCommand { action_id };

        Self::ClientCommand(client_command)
    }

    pub fn settings(
        locale: String,
        view_distance: i8,
        chat_flags: i32,
        chat_colors: bool,
        skin_parts: u8,
        main_hand: i32,
    ) -> Self {
        let settings = Settings {
            locale,
            view_distance,
            chat_flags,
            chat_colors,
            skin_parts,
            main_hand,
        };

        Self::Settings(settings)
    }

    pub fn server_bound_transaction(window_id: i8, action: i16, accepted: bool) -> Self {
        let server_bound_transaction = ServerBoundTransaction {
            window_id,
            action,
            accepted,
        };

        Self::ServerBoundTransaction(server_bound_transaction)
    }

    pub fn enchant_item(window_id: i8, enchantment: i8) -> Self {
        let enchant_item = EnchantItem {
            window_id,
            enchantment,
        };

        Self::EnchantItem(enchant_item)
    }

    pub fn window_click(
        window_id: u8,
        slot: i16,
        mouse_button: i8,
        action: i16,
        mode: i8,
        item: Option<Slot>,
    ) -> Self {
        let window_click = WindowClick {
            window_id,
            slot,
            mouse_button,
            action,
            mode,
            item,
        };

        Self::WindowClick(window_click)
    }

    pub fn server_bound_close_window(window_id: u8) -> Self {
        let server_bound_close_window = ServerBoundCloseWindow { window_id };

        Self::ServerBoundCloseWindow(server_bound_close_window)
    }

    pub fn server_bound_custom_payload(channel: String, data: Vec<u8>) -> Self {
        let server_bound_custom_payload = ServerBoundCustomPayload { channel, data };

        Self::ServerBoundCustomPayload(server_bound_custom_payload)
    }

    pub fn use_entity(target: i32, mouse: i32) -> Self {
        let use_entity = UseEntity { target, mouse };

        Self::UseEntity(use_entity)
    }

    pub fn server_bound_keep_alive(keep_alive_id: i32) -> Self {
        let server_bound_keep_alive = ServerBoundKeepAlive { keep_alive_id };

        Self::ServerBoundKeepAlive(server_bound_keep_alive)
    }

    pub fn server_bound_position(x: f64, y: f64, z: f64, on_ground: bool) -> Self {
        let server_bound_position = ServerBoundPosition { x, y, z, on_ground };

        Self::ServerBoundPosition(server_bound_position)
    }

    pub fn position_look(x: f64, y: f64, z: f64, yaw: f32, pitch: f32, on_ground: bool) -> Self {
        let position_look = PositionLook {
            x,
            y,
            z,
            yaw,
            pitch,
            on_ground,
        };

        Self::PositionLook(position_look)
    }

    pub fn look(yaw: f32, pitch: f32, on_ground: bool) -> Self {
        let look = Look {
            yaw,
            pitch,
            on_ground,
        };

        Self::Look(look)
    }

    pub fn flying(on_ground: bool) -> Self {
        let flying = Flying { on_ground };

        Self::Flying(flying)
    }

    pub fn server_bound_vehicle_move(x: f64, y: f64, z: f64, yaw: f32, pitch: f32) -> Self {
        let server_bound_vehicle_move = ServerBoundVehicleMove {
            x,
            y,
            z,
            yaw,
            pitch,
        };

        Self::ServerBoundVehicleMove(server_bound_vehicle_move)
    }

    pub fn steer_boat(left_paddle: bool, right_paddle: bool) -> Self {
        let steer_boat = SteerBoat {
            left_paddle,
            right_paddle,
        };

        Self::SteerBoat(steer_boat)
    }

    pub fn craft_recipe_request(window_id: i8, recipe: i32, make_all: bool) -> Self {
        let craft_recipe_request = CraftRecipeRequest {
            window_id,
            recipe,
            make_all,
        };

        Self::CraftRecipeRequest(craft_recipe_request)
    }

    pub fn server_bound_abilities(flags: i8, flying_speed: f32, walking_speed: f32) -> Self {
        let server_bound_abilities = ServerBoundAbilities {
            flags,
            flying_speed,
            walking_speed,
        };

        Self::ServerBoundAbilities(server_bound_abilities)
    }

    pub fn block_dig(status: i8, location: Position, face: i8) -> Self {
        let block_dig = BlockDig {
            status,
            location,
            face,
        };

        Self::BlockDig(block_dig)
    }

    pub fn entity_action(entity_id: i32, action_id: i32, jump_boost: i32) -> Self {
        let entity_action = EntityAction {
            entity_id,
            action_id,
            jump_boost,
        };

        Self::EntityAction(entity_action)
    }

    pub fn steer_vehicle(sideways: f32, forward: f32, jump: u8) -> Self {
        let steer_vehicle = SteerVehicle {
            sideways,
            forward,
            jump,
        };

        Self::SteerVehicle(steer_vehicle)
    }

    pub fn crafting_book_data(type_: i32) -> Self {
        let crafting_book_data = CraftingBookData { type_ };

        Self::CraftingBookData(crafting_book_data)
    }

    pub fn resource_pack_receive(result: i32) -> Self {
        let resource_pack_receive = ResourcePackReceive { result };

        Self::ResourcePackReceive(resource_pack_receive)
    }

    pub fn server_bound_held_item_slot(slot_id: i16) -> Self {
        let server_bound_held_item_slot = ServerBoundHeldItemSlot { slot_id };

        Self::ServerBoundHeldItemSlot(server_bound_held_item_slot)
    }

    pub fn set_creative_slot(slot: i16, item: Option<Slot>) -> Self {
        let set_creative_slot = SetCreativeSlot { slot, item };

        Self::SetCreativeSlot(set_creative_slot)
    }

    pub fn update_sign(
        location: Position,
        text1: String,
        text2: String,
        text3: String,
        text4: String,
    ) -> Self {
        let update_sign = UpdateSign {
            location,
            text1,
            text2,
            text3,
            text4,
        };

        Self::UpdateSign(update_sign)
    }

    pub fn arm_animation(hand: i32) -> Self {
        let arm_animation = ArmAnimation { hand };

        Self::ArmAnimation(arm_animation)
    }

    pub fn spectate(target: Uuid) -> Self {
        let spectate = Spectate { target };

        Self::Spectate(spectate)
    }

    pub fn block_place(
        location: Position,
        direction: i32,
        hand: i32,
        cursor_x: f32,
        cursor_y: f32,
        cursor_z: f32,
    ) -> Self {
        let block_place = BlockPlace {
            location,
            direction,
            hand,
            cursor_x,
            cursor_y,
            cursor_z,
        };

        Self::BlockPlace(block_place)
    }

    pub fn use_item(hand: i32) -> Self {
        let use_item = UseItem { hand };

        Self::UseItem(use_item)
    }

    pub fn advancement_tab(action: i32) -> Self {
        let advancement_tab = AdvancementTab { action };

        Self::AdvancementTab(advancement_tab)
    }
}

pub enum ClientBoundGamePacket {
    SpawnEntity(SpawnEntity),
    SpawnEntityExperienceOrb(SpawnEntityExperienceOrb),
    SpawnEntityWeather(SpawnEntityWeather),
    SpawnEntityLiving(SpawnEntityLiving),
    SpawnEntityPainting(SpawnEntityPainting),
    NamedEntitySpawn(NamedEntitySpawn),
    Animation(Animation),
    Statistics,
    Advancements(Advancements),
    BlockBreakAnimation(BlockBreakAnimation),
    TileEntityData(TileEntityData),
    BlockAction(BlockAction),
    BlockChange(BlockChange),
    BossBar(BossBar),
    Difficulty(Difficulty),
    ClientBoundTabComplete,
    ClientBoundChat(ClientBoundChat),
    MultiBlockChange(MultiBlockChange),
    ClientBoundTransaction(ClientBoundTransaction),
    ClientBoundCloseWindow(ClientBoundCloseWindow),
    OpenWindow(OpenWindow),
    WindowItems(WindowItems),
    CraftProgressBar(CraftProgressBar),
    SetSlot(SetSlot),
    SetCooldown(SetCooldown),
    ClientBoundCustomPayload(ClientBoundCustomPayload),
    NamedSoundEffect(NamedSoundEffect),
    KickDisconnect(KickDisconnect),
    EntityStatus(EntityStatus),
    Explosion(Explosion),
    UnloadChunk(UnloadChunk),
    GameStateChange(GameStateChange),
    ClientBoundKeepAlive(ClientBoundKeepAlive),
    MapChunk(MapChunk),
    WorldEvent(WorldEvent),
    WorldParticles(WorldParticles),
    JoinGame(JoinGame),
    Map(Map),
    RelEntityMove(RelEntityMove),
    EntityMoveLook(EntityMoveLook),
    EntityLook(EntityLook),
    Entity(Entity),
    ClientBoundVehicleMove(ClientBoundVehicleMove),
    OpenSignEntity(OpenSignEntity),
    CraftRecipeResponse(CraftRecipeResponse),
    ClientBoundAbilities(ClientBoundAbilities),
    CombatEvent(CombatEvent),
    PlayerInfo(PlayerInfo),
    ClientBoundPosition(ClientBoundPosition),
    Bed(Bed),
    UnlockRecipes(UnlockRecipes),
    EntityDestroy,
    RemoveEntityEffect(RemoveEntityEffect),
    ResourcePackSend(ResourcePackSend),
    Respawn(Respawn),
    EntityHeadRotation(EntityHeadRotation),
    WorldBorder(WorldBorder),
    Camera(Camera),
    ClientBoundHeldItemSlot(ClientBoundHeldItemSlot),
    ScoreboardDisplayObjective(ScoreboardDisplayObjective),
    EntityMetadata(EntityMetadata),
    AttachEntity(AttachEntity),
    EntityVelocity(EntityVelocity),
    EntityEquipment(EntityEquipment),
    Experience(Experience),
    UpdateHealth(UpdateHealth),
    ScoreboardObjective(ScoreboardObjective),
    SetPassengers(SetPassengers),
    Teams(Teams),
    ScoreboardScore(ScoreboardScore),
    SpawnPosition(SpawnPosition),
    UpdateTime(UpdateTime),
    Title(Title),
    SoundEffect(SoundEffect),
    PlayerlistHeader(PlayerlistHeader),
    Collect(Collect),
    EntityTeleport(EntityTeleport),
    EntityUpdateAttributes(EntityUpdateAttributes),
    EntityEffect(EntityEffect),
    SelectAdvancementTab(SelectAdvancementTab),
}

impl ClientBoundGamePacket {
    pub fn get_type_id(&self) -> u8 {
        match self {
            Self::SpawnEntity(_) => 0x00,
            Self::SpawnEntityExperienceOrb(_) => 0x01,
            Self::SpawnEntityWeather(_) => 0x02,
            Self::SpawnEntityLiving(_) => 0x03,
            Self::SpawnEntityPainting(_) => 0x04,
            Self::NamedEntitySpawn(_) => 0x05,
            Self::Animation(_) => 0x06,
            Self::Statistics => 0x07,
            Self::Advancements(_) => 0x4D,
            Self::BlockBreakAnimation(_) => 0x08,
            Self::TileEntityData(_) => 0x09,
            Self::BlockAction(_) => 0x0A,
            Self::BlockChange(_) => 0x0B,
            Self::BossBar(_) => 0x0C,
            Self::Difficulty(_) => 0x0D,
            Self::ClientBoundTabComplete => 0x0E,
            Self::ClientBoundChat(_) => 0x0F,
            Self::MultiBlockChange(_) => 0x10,
            Self::ClientBoundTransaction(_) => 0x11,
            Self::ClientBoundCloseWindow(_) => 0x12,
            Self::OpenWindow(_) => 0x13,
            Self::WindowItems(_) => 0x14,
            Self::CraftProgressBar(_) => 0x15,
            Self::SetSlot(_) => 0x16,
            Self::SetCooldown(_) => 0x17,
            Self::ClientBoundCustomPayload(_) => 0x18,
            Self::NamedSoundEffect(_) => 0x19,
            Self::KickDisconnect(_) => 0x1A,
            Self::EntityStatus(_) => 0x1B,
            Self::Explosion(_) => 0x1C,
            Self::UnloadChunk(_) => 0x1D,
            Self::GameStateChange(_) => 0x1E,
            Self::ClientBoundKeepAlive(_) => 0x1F,
            Self::MapChunk(_) => 0x20,
            Self::WorldEvent(_) => 0x21,
            Self::WorldParticles(_) => 0x22,
            Self::JoinGame(_) => 0x23,
            Self::Map(_) => 0x24,
            Self::RelEntityMove(_) => 0x26,
            Self::EntityMoveLook(_) => 0x27,
            Self::EntityLook(_) => 0x28,
            Self::Entity(_) => 0x25,
            Self::ClientBoundVehicleMove(_) => 0x29,
            Self::OpenSignEntity(_) => 0x2A,
            Self::CraftRecipeResponse(_) => 0x2B,
            Self::ClientBoundAbilities(_) => 0x2C,
            Self::CombatEvent(_) => 0x2D,
            Self::PlayerInfo(_) => 0x2E,
            Self::ClientBoundPosition(_) => 0x2F,
            Self::Bed(_) => 0x30,
            Self::UnlockRecipes(_) => 0x31,
            Self::EntityDestroy => 0x32,
            Self::RemoveEntityEffect(_) => 0x33,
            Self::ResourcePackSend(_) => 0x34,
            Self::Respawn(_) => 0x35,
            Self::EntityHeadRotation(_) => 0x36,
            Self::WorldBorder(_) => 0x38,
            Self::Camera(_) => 0x39,
            Self::ClientBoundHeldItemSlot(_) => 0x3A,
            Self::ScoreboardDisplayObjective(_) => 0x3B,
            Self::EntityMetadata(_) => 0x3C,
            Self::AttachEntity(_) => 0x3D,
            Self::EntityVelocity(_) => 0x3E,
            Self::EntityEquipment(_) => 0x3F,
            Self::Experience(_) => 0x40,
            Self::UpdateHealth(_) => 0x41,
            Self::ScoreboardObjective(_) => 0x42,
            Self::SetPassengers(_) => 0x43,
            Self::Teams(_) => 0x44,
            Self::ScoreboardScore(_) => 0x45,
            Self::SpawnPosition(_) => 0x46,
            Self::UpdateTime(_) => 0x47,
            Self::Title(_) => 0x48,
            Self::SoundEffect(_) => 0x49,
            Self::PlayerlistHeader(_) => 0x4A,
            Self::Collect(_) => 0x4B,
            Self::EntityTeleport(_) => 0x4C,
            Self::EntityUpdateAttributes(_) => 0x4E,
            Self::EntityEffect(_) => 0x4F,
            Self::SelectAdvancementTab(_) => 0x37,
        }
    }

    pub fn decode<R: Read>(type_id: u8, reader: &mut R) -> Result<Self, DecodeError> {
        match type_id {
            0x00 => {
                let spawn_entity = SpawnEntity::decode(reader)?;

                Ok(Self::SpawnEntity(spawn_entity))
            }
            0x01 => {
                let spawn_entity_experience_orb = SpawnEntityExperienceOrb::decode(reader)?;

                Ok(Self::SpawnEntityExperienceOrb(spawn_entity_experience_orb))
            }
            0x02 => {
                let spawn_entity_weather = SpawnEntityWeather::decode(reader)?;

                Ok(Self::SpawnEntityWeather(spawn_entity_weather))
            }
            0x03 => {
                let spawn_entity_living = SpawnEntityLiving::decode(reader)?;

                Ok(Self::SpawnEntityLiving(spawn_entity_living))
            }
            0x04 => {
                let spawn_entity_painting = SpawnEntityPainting::decode(reader)?;

                Ok(Self::SpawnEntityPainting(spawn_entity_painting))
            }
            0x05 => {
                let named_entity_spawn = NamedEntitySpawn::decode(reader)?;

                Ok(Self::NamedEntitySpawn(named_entity_spawn))
            }
            0x06 => {
                let animation = Animation::decode(reader)?;

                Ok(Self::Animation(animation))
            }
            0x07 => Ok(Self::Statistics),
            0x4D => {
                let advancements = Advancements::decode(reader)?;

                Ok(Self::Advancements(advancements))
            }
            0x08 => {
                let block_break_animation = BlockBreakAnimation::decode(reader)?;

                Ok(Self::BlockBreakAnimation(block_break_animation))
            }
            0x09 => {
                let tile_entity_data = TileEntityData::decode(reader)?;

                Ok(Self::TileEntityData(tile_entity_data))
            }
            0x0A => {
                let block_action = BlockAction::decode(reader)?;

                Ok(Self::BlockAction(block_action))
            }
            0x0B => {
                let block_change = BlockChange::decode(reader)?;

                Ok(Self::BlockChange(block_change))
            }
            0x0C => {
                let boss_bar = BossBar::decode(reader)?;

                Ok(Self::BossBar(boss_bar))
            }
            0x0D => {
                let difficulty = Difficulty::decode(reader)?;

                Ok(Self::Difficulty(difficulty))
            }
            0x0E => Ok(Self::ClientBoundTabComplete),
            0x0F => {
                let client_bound_chat = ClientBoundChat::decode(reader)?;

                Ok(Self::ClientBoundChat(client_bound_chat))
            }
            0x10 => {
                let multi_block_change = MultiBlockChange::decode(reader)?;

                Ok(Self::MultiBlockChange(multi_block_change))
            }
            0x11 => {
                let client_bound_transaction = ClientBoundTransaction::decode(reader)?;

                Ok(Self::ClientBoundTransaction(client_bound_transaction))
            }
            0x12 => {
                let client_bound_close_window = ClientBoundCloseWindow::decode(reader)?;

                Ok(Self::ClientBoundCloseWindow(client_bound_close_window))
            }
            0x13 => {
                let open_window = OpenWindow::decode(reader)?;

                Ok(Self::OpenWindow(open_window))
            }
            0x14 => {
                let window_items = WindowItems::decode(reader)?;

                Ok(Self::WindowItems(window_items))
            }
            0x15 => {
                let craft_progress_bar = CraftProgressBar::decode(reader)?;

                Ok(Self::CraftProgressBar(craft_progress_bar))
            }
            0x16 => {
                let set_slot = SetSlot::decode(reader)?;

                Ok(Self::SetSlot(set_slot))
            }
            0x17 => {
                let set_cooldown = SetCooldown::decode(reader)?;

                Ok(Self::SetCooldown(set_cooldown))
            }
            0x18 => {
                let client_bound_custom_payload = ClientBoundCustomPayload::decode(reader)?;

                Ok(Self::ClientBoundCustomPayload(client_bound_custom_payload))
            }
            0x19 => {
                let named_sound_effect = NamedSoundEffect::decode(reader)?;

                Ok(Self::NamedSoundEffect(named_sound_effect))
            }
            0x1A => {
                let kick_disconnect = KickDisconnect::decode(reader)?;

                Ok(Self::KickDisconnect(kick_disconnect))
            }
            0x1B => {
                let entity_status = EntityStatus::decode(reader)?;

                Ok(Self::EntityStatus(entity_status))
            }
            0x1C => {
                let explosion = Explosion::decode(reader)?;

                Ok(Self::Explosion(explosion))
            }
            0x1D => {
                let unload_chunk = UnloadChunk::decode(reader)?;

                Ok(Self::UnloadChunk(unload_chunk))
            }
            0x1E => {
                let game_state_change = GameStateChange::decode(reader)?;

                Ok(Self::GameStateChange(game_state_change))
            }
            0x1F => {
                let client_bound_keep_alive = ClientBoundKeepAlive::decode(reader)?;

                Ok(Self::ClientBoundKeepAlive(client_bound_keep_alive))
            }
            0x20 => {
                let map_chunk = MapChunk::decode(reader)?;

                Ok(Self::MapChunk(map_chunk))
            }
            0x21 => {
                let world_event = WorldEvent::decode(reader)?;

                Ok(Self::WorldEvent(world_event))
            }
            0x22 => {
                let world_particles = WorldParticles::decode(reader)?;

                Ok(Self::WorldParticles(world_particles))
            }
            0x23 => {
                let join_game = JoinGame::decode(reader)?;

                Ok(Self::JoinGame(join_game))
            }
            0x24 => {
                let map = Map::decode(reader)?;

                Ok(Self::Map(map))
            }
            0x26 => {
                let rel_entity_move = RelEntityMove::decode(reader)?;

                Ok(Self::RelEntityMove(rel_entity_move))
            }
            0x27 => {
                let entity_move_look = EntityMoveLook::decode(reader)?;

                Ok(Self::EntityMoveLook(entity_move_look))
            }
            0x28 => {
                let entity_look = EntityLook::decode(reader)?;

                Ok(Self::EntityLook(entity_look))
            }
            0x25 => {
                let entity = Entity::decode(reader)?;

                Ok(Self::Entity(entity))
            }
            0x29 => {
                let client_bound_vehicle_move = ClientBoundVehicleMove::decode(reader)?;

                Ok(Self::ClientBoundVehicleMove(client_bound_vehicle_move))
            }
            0x2A => {
                let open_sign_entity = OpenSignEntity::decode(reader)?;

                Ok(Self::OpenSignEntity(open_sign_entity))
            }
            0x2B => {
                let craft_recipe_response = CraftRecipeResponse::decode(reader)?;

                Ok(Self::CraftRecipeResponse(craft_recipe_response))
            }
            0x2C => {
                let client_bound_abilities = ClientBoundAbilities::decode(reader)?;

                Ok(Self::ClientBoundAbilities(client_bound_abilities))
            }
            0x2D => {
                let combat_event = CombatEvent::decode(reader)?;

                Ok(Self::CombatEvent(combat_event))
            }
            0x2E => {
                let player_info = PlayerInfo::decode(reader)?;

                Ok(Self::PlayerInfo(player_info))
            }
            0x2F => {
                let client_bound_position = ClientBoundPosition::decode(reader)?;

                Ok(Self::ClientBoundPosition(client_bound_position))
            }
            0x30 => {
                let bed = Bed::decode(reader)?;

                Ok(Self::Bed(bed))
            }
            0x31 => {
                let unlock_recipes = UnlockRecipes::decode(reader)?;

                Ok(Self::UnlockRecipes(unlock_recipes))
            }
            0x32 => Ok(Self::EntityDestroy),
            0x33 => {
                let remove_entity_effect = RemoveEntityEffect::decode(reader)?;

                Ok(Self::RemoveEntityEffect(remove_entity_effect))
            }
            0x34 => {
                let resource_pack_send = ResourcePackSend::decode(reader)?;

                Ok(Self::ResourcePackSend(resource_pack_send))
            }
            0x35 => {
                let respawn = Respawn::decode(reader)?;

                Ok(Self::Respawn(respawn))
            }
            0x36 => {
                let entity_head_rotation = EntityHeadRotation::decode(reader)?;

                Ok(Self::EntityHeadRotation(entity_head_rotation))
            }
            0x38 => {
                let world_border = WorldBorder::decode(reader)?;

                Ok(Self::WorldBorder(world_border))
            }
            0x39 => {
                let camera = Camera::decode(reader)?;

                Ok(Self::Camera(camera))
            }
            0x3A => {
                let client_bound_held_item_slot = ClientBoundHeldItemSlot::decode(reader)?;

                Ok(Self::ClientBoundHeldItemSlot(client_bound_held_item_slot))
            }
            0x3B => {
                let scoreboard_display_objective = ScoreboardDisplayObjective::decode(reader)?;

                Ok(Self::ScoreboardDisplayObjective(
                    scoreboard_display_objective,
                ))
            }
            0x3C => {
                let entity_metadata = EntityMetadata::decode(reader)?;

                Ok(Self::EntityMetadata(entity_metadata))
            }
            0x3D => {
                let attach_entity = AttachEntity::decode(reader)?;

                Ok(Self::AttachEntity(attach_entity))
            }
            0x3E => {
                let entity_velocity = EntityVelocity::decode(reader)?;

                Ok(Self::EntityVelocity(entity_velocity))
            }
            0x3F => {
                let entity_equipment = EntityEquipment::decode(reader)?;

                Ok(Self::EntityEquipment(entity_equipment))
            }
            0x40 => {
                let experience = Experience::decode(reader)?;

                Ok(Self::Experience(experience))
            }
            0x41 => {
                let update_health = UpdateHealth::decode(reader)?;

                Ok(Self::UpdateHealth(update_health))
            }
            0x42 => {
                let scoreboard_objective = ScoreboardObjective::decode(reader)?;

                Ok(Self::ScoreboardObjective(scoreboard_objective))
            }
            0x43 => {
                let set_passengers = SetPassengers::decode(reader)?;

                Ok(Self::SetPassengers(set_passengers))
            }
            0x44 => {
                let teams = Teams::decode(reader)?;

                Ok(Self::Teams(teams))
            }
            0x45 => {
                let scoreboard_score = ScoreboardScore::decode(reader)?;

                Ok(Self::ScoreboardScore(scoreboard_score))
            }
            0x46 => {
                let spawn_position = SpawnPosition::decode(reader)?;

                Ok(Self::SpawnPosition(spawn_position))
            }
            0x47 => {
                let update_time = UpdateTime::decode(reader)?;

                Ok(Self::UpdateTime(update_time))
            }
            0x48 => {
                let title = Title::decode(reader)?;

                Ok(Self::Title(title))
            }
            0x49 => {
                let sound_effect = SoundEffect::decode(reader)?;

                Ok(Self::SoundEffect(sound_effect))
            }
            0x4A => {
                let playerlist_header = PlayerlistHeader::decode(reader)?;

                Ok(Self::PlayerlistHeader(playerlist_header))
            }
            0x4B => {
                let collect = Collect::decode(reader)?;

                Ok(Self::Collect(collect))
            }
            0x4C => {
                let entity_teleport = EntityTeleport::decode(reader)?;

                Ok(Self::EntityTeleport(entity_teleport))
            }
            0x4E => {
                let entity_update_attributes = EntityUpdateAttributes::decode(reader)?;

                Ok(Self::EntityUpdateAttributes(entity_update_attributes))
            }
            0x4F => {
                let entity_effect = EntityEffect::decode(reader)?;

                Ok(Self::EntityEffect(entity_effect))
            }
            0x37 => {
                let select_advancement_tab = SelectAdvancementTab::decode(reader)?;

                Ok(Self::SelectAdvancementTab(select_advancement_tab))
            }
            _ => Err(DecodeError::UnknownPacketType { type_id }),
        }
    }

    pub fn spawn_entity(
        entity_id: i32,
        object_uuid: Uuid,
        type_: i8,
        x: f64,
        y: f64,
        z: f64,
        pitch: i8,
        yaw: i8,
        object_data: i32,
        velocity_x: i16,
        velocity_y: i16,
        velocity_z: i16,
    ) -> Self {
        let spawn_entity = SpawnEntity {
            entity_id,
            object_uuid,
            type_,
            x,
            y,
            z,
            pitch,
            yaw,
            object_data,
            velocity_x,
            velocity_y,
            velocity_z,
        };

        Self::SpawnEntity(spawn_entity)
    }

    pub fn spawn_entity_experience_orb(entity_id: i32, x: f64, y: f64, z: f64, count: i16) -> Self {
        let spawn_entity_experience_orb = SpawnEntityExperienceOrb {
            entity_id,
            x,
            y,
            z,
            count,
        };

        Self::SpawnEntityExperienceOrb(spawn_entity_experience_orb)
    }

    pub fn spawn_entity_weather(entity_id: i32, type_: i8, x: f64, y: f64, z: f64) -> Self {
        let spawn_entity_weather = SpawnEntityWeather {
            entity_id,
            type_,
            x,
            y,
            z,
        };

        Self::SpawnEntityWeather(spawn_entity_weather)
    }

    pub fn spawn_entity_living(
        entity_id: i32,
        entity_uuid: Uuid,
        type_: i32,
        x: f64,
        y: f64,
        z: f64,
        yaw: i8,
        pitch: i8,
        head_pitch: i8,
        velocity_x: i16,
        velocity_y: i16,
        velocity_z: i16,
        metadata: Metadata,
    ) -> Self {
        let spawn_entity_living = SpawnEntityLiving {
            entity_id,
            entity_uuid,
            type_,
            x,
            y,
            z,
            yaw,
            pitch,
            head_pitch,
            velocity_x,
            velocity_y,
            velocity_z,
            metadata,
        };

        Self::SpawnEntityLiving(spawn_entity_living)
    }

    pub fn spawn_entity_painting(
        entity_id: i32,
        entity_uuid: Uuid,
        title: String,
        location: Position,
        direction: u8,
    ) -> Self {
        let spawn_entity_painting = SpawnEntityPainting {
            entity_id,
            entity_uuid,
            title,
            location,
            direction,
        };

        Self::SpawnEntityPainting(spawn_entity_painting)
    }

    pub fn named_entity_spawn(
        entity_id: i32,
        player_uuid: Uuid,
        x: f64,
        y: f64,
        z: f64,
        yaw: i8,
        pitch: i8,
        metadata: Metadata,
    ) -> Self {
        let named_entity_spawn = NamedEntitySpawn {
            entity_id,
            player_uuid,
            x,
            y,
            z,
            yaw,
            pitch,
            metadata,
        };

        Self::NamedEntitySpawn(named_entity_spawn)
    }

    pub fn animation(entity_id: i32, animation: u8) -> Self {
        let animation = Animation {
            entity_id,
            animation,
        };

        Self::Animation(animation)
    }

    pub fn statistics() -> Self {
        Self::Statistics
    }

    pub fn advancements(reset: bool) -> Self {
        let advancements = Advancements { reset };

        Self::Advancements(advancements)
    }

    pub fn block_break_animation(entity_id: i32, location: Position, destroy_stage: i8) -> Self {
        let block_break_animation = BlockBreakAnimation {
            entity_id,
            location,
            destroy_stage,
        };

        Self::BlockBreakAnimation(block_break_animation)
    }

    pub fn tile_entity_data(location: Position, action: u8, nbt_data: CompoundTag) -> Self {
        let tile_entity_data = TileEntityData {
            location,
            action,
            nbt_data,
        };

        Self::TileEntityData(tile_entity_data)
    }

    pub fn block_action(location: Position, byte1: u8, byte2: u8, block_id: i32) -> Self {
        let block_action = BlockAction {
            location,
            byte1,
            byte2,
            block_id,
        };

        Self::BlockAction(block_action)
    }

    pub fn block_change(location: Position, type_: i32) -> Self {
        let block_change = BlockChange { location, type_ };

        Self::BlockChange(block_change)
    }

    pub fn boss_bar(entity_uuid: Uuid, action: i32) -> Self {
        let boss_bar = BossBar {
            entity_uuid,
            action,
        };

        Self::BossBar(boss_bar)
    }

    pub fn difficulty(difficulty: u8) -> Self {
        let difficulty = Difficulty { difficulty };

        Self::Difficulty(difficulty)
    }

    pub fn client_bound_tab_complete() -> Self {
        Self::ClientBoundTabComplete
    }

    pub fn client_bound_chat(message: String, position: i8) -> Self {
        let client_bound_chat = ClientBoundChat { message, position };

        Self::ClientBoundChat(client_bound_chat)
    }

    pub fn multi_block_change(chunk_x: i32, chunk_z: i32) -> Self {
        let multi_block_change = MultiBlockChange { chunk_x, chunk_z };

        Self::MultiBlockChange(multi_block_change)
    }

    pub fn client_bound_transaction(window_id: i8, action: i16, accepted: bool) -> Self {
        let client_bound_transaction = ClientBoundTransaction {
            window_id,
            action,
            accepted,
        };

        Self::ClientBoundTransaction(client_bound_transaction)
    }

    pub fn client_bound_close_window(window_id: u8) -> Self {
        let client_bound_close_window = ClientBoundCloseWindow { window_id };

        Self::ClientBoundCloseWindow(client_bound_close_window)
    }

    pub fn open_window(
        window_id: u8,
        inventory_type: String,
        window_title: String,
        slot_count: u8,
    ) -> Self {
        let open_window = OpenWindow {
            window_id,
            inventory_type,
            window_title,
            slot_count,
        };

        Self::OpenWindow(open_window)
    }

    pub fn window_items(window_id: u8) -> Self {
        let window_items = WindowItems { window_id };

        Self::WindowItems(window_items)
    }

    pub fn craft_progress_bar(window_id: u8, property: i16, value: i16) -> Self {
        let craft_progress_bar = CraftProgressBar {
            window_id,
            property,
            value,
        };

        Self::CraftProgressBar(craft_progress_bar)
    }

    pub fn set_slot(window_id: i8, slot: i16, item: Option<Slot>) -> Self {
        let set_slot = SetSlot {
            window_id,
            slot,
            item,
        };

        Self::SetSlot(set_slot)
    }

    pub fn set_cooldown(item_id: i32, cooldown_ticks: i32) -> Self {
        let set_cooldown = SetCooldown {
            item_id,
            cooldown_ticks,
        };

        Self::SetCooldown(set_cooldown)
    }

    pub fn client_bound_custom_payload(channel: String, data: Vec<u8>) -> Self {
        let client_bound_custom_payload = ClientBoundCustomPayload { channel, data };

        Self::ClientBoundCustomPayload(client_bound_custom_payload)
    }

    pub fn named_sound_effect(
        sound_name: String,
        sound_category: i32,
        x: i32,
        y: i32,
        z: i32,
        volume: f32,
        pitch: f32,
    ) -> Self {
        let named_sound_effect = NamedSoundEffect {
            sound_name,
            sound_category,
            x,
            y,
            z,
            volume,
            pitch,
        };

        Self::NamedSoundEffect(named_sound_effect)
    }

    pub fn kick_disconnect(reason: String) -> Self {
        let kick_disconnect = KickDisconnect { reason };

        Self::KickDisconnect(kick_disconnect)
    }

    pub fn entity_status(entity_id: i32, entity_status: i8) -> Self {
        let entity_status = EntityStatus {
            entity_id,
            entity_status,
        };

        Self::EntityStatus(entity_status)
    }

    pub fn explosion(
        x: f32,
        y: f32,
        z: f32,
        radius: f32,
        player_motion_x: f32,
        player_motion_y: f32,
        player_motion_z: f32,
    ) -> Self {
        let explosion = Explosion {
            x,
            y,
            z,
            radius,
            player_motion_x,
            player_motion_y,
            player_motion_z,
        };

        Self::Explosion(explosion)
    }

    pub fn unload_chunk(chunk_x: i32, chunk_z: i32) -> Self {
        let unload_chunk = UnloadChunk { chunk_x, chunk_z };

        Self::UnloadChunk(unload_chunk)
    }

    pub fn game_state_change(reason: u8, game_mode: f32) -> Self {
        let game_state_change = GameStateChange { reason, game_mode };

        Self::GameStateChange(game_state_change)
    }

    pub fn client_bound_keep_alive(keep_alive_id: i32) -> Self {
        let client_bound_keep_alive = ClientBoundKeepAlive { keep_alive_id };

        Self::ClientBoundKeepAlive(client_bound_keep_alive)
    }

    pub fn map_chunk(x: i32, z: i32, ground_up: bool, bit_map: i32, chunk_data: Vec<u8>) -> Self {
        let map_chunk = MapChunk {
            x,
            z,
            ground_up,
            bit_map,
            chunk_data,
        };

        Self::MapChunk(map_chunk)
    }

    pub fn world_event(effect_id: i32, location: Position, data: i32, global: bool) -> Self {
        let world_event = WorldEvent {
            effect_id,
            location,
            data,
            global,
        };

        Self::WorldEvent(world_event)
    }

    pub fn world_particles(
        particle_id: i32,
        long_distance: bool,
        x: f32,
        y: f32,
        z: f32,
        offset_x: f32,
        offset_y: f32,
        offset_z: f32,
        particle_data: f32,
        particles: i32,
    ) -> Self {
        let world_particles = WorldParticles {
            particle_id,
            long_distance,
            x,
            y,
            z,
            offset_x,
            offset_y,
            offset_z,
            particle_data,
            particles,
        };

        Self::WorldParticles(world_particles)
    }

    pub fn join_game(
        entity_id: i32,
        game_mode: u8,
        dimension: i32,
        difficulty: u8,
        max_players: u8,
        level_type: String,
        reduced_debug_info: bool,
    ) -> Self {
        let join_game = JoinGame {
            entity_id,
            game_mode,
            dimension,
            difficulty,
            max_players,
            level_type,
            reduced_debug_info,
        };

        Self::JoinGame(join_game)
    }

    pub fn map(item_damage: i32, scale: i8, tracking_position: bool, columns: i8) -> Self {
        let map = Map {
            item_damage,
            scale,
            tracking_position,
            columns,
        };

        Self::Map(map)
    }

    pub fn rel_entity_move(entity_id: i32, d_x: i16, d_y: i16, d_z: i16, on_ground: bool) -> Self {
        let rel_entity_move = RelEntityMove {
            entity_id,
            d_x,
            d_y,
            d_z,
            on_ground,
        };

        Self::RelEntityMove(rel_entity_move)
    }

    pub fn entity_move_look(
        entity_id: i32,
        d_x: i16,
        d_y: i16,
        d_z: i16,
        yaw: i8,
        pitch: i8,
        on_ground: bool,
    ) -> Self {
        let entity_move_look = EntityMoveLook {
            entity_id,
            d_x,
            d_y,
            d_z,
            yaw,
            pitch,
            on_ground,
        };

        Self::EntityMoveLook(entity_move_look)
    }

    pub fn entity_look(entity_id: i32, yaw: i8, pitch: i8, on_ground: bool) -> Self {
        let entity_look = EntityLook {
            entity_id,
            yaw,
            pitch,
            on_ground,
        };

        Self::EntityLook(entity_look)
    }

    pub fn entity(entity_id: i32) -> Self {
        let entity = Entity { entity_id };

        Self::Entity(entity)
    }

    pub fn client_bound_vehicle_move(x: f64, y: f64, z: f64, yaw: f32, pitch: f32) -> Self {
        let client_bound_vehicle_move = ClientBoundVehicleMove {
            x,
            y,
            z,
            yaw,
            pitch,
        };

        Self::ClientBoundVehicleMove(client_bound_vehicle_move)
    }

    pub fn open_sign_entity(location: Position) -> Self {
        let open_sign_entity = OpenSignEntity { location };

        Self::OpenSignEntity(open_sign_entity)
    }

    pub fn craft_recipe_response(window_id: i8, recipe: i32) -> Self {
        let craft_recipe_response = CraftRecipeResponse { window_id, recipe };

        Self::CraftRecipeResponse(craft_recipe_response)
    }

    pub fn client_bound_abilities(flags: i8, flying_speed: f32, walking_speed: f32) -> Self {
        let client_bound_abilities = ClientBoundAbilities {
            flags,
            flying_speed,
            walking_speed,
        };

        Self::ClientBoundAbilities(client_bound_abilities)
    }

    pub fn combat_event(event: i32) -> Self {
        let combat_event = CombatEvent { event };

        Self::CombatEvent(combat_event)
    }

    pub fn player_info(action: i32) -> Self {
        let player_info = PlayerInfo { action };

        Self::PlayerInfo(player_info)
    }

    pub fn client_bound_position(
        x: f64,
        y: f64,
        z: f64,
        yaw: f32,
        pitch: f32,
        flags: i8,
        teleport_id: i32,
    ) -> Self {
        let client_bound_position = ClientBoundPosition {
            x,
            y,
            z,
            yaw,
            pitch,
            flags,
            teleport_id,
        };

        Self::ClientBoundPosition(client_bound_position)
    }

    pub fn bed(entity_id: i32, location: Position) -> Self {
        let bed = Bed {
            entity_id,
            location,
        };

        Self::Bed(bed)
    }

    pub fn unlock_recipes(
        action: i32,
        crafting_book_open: bool,
        filtering_craftable: bool,
    ) -> Self {
        let unlock_recipes = UnlockRecipes {
            action,
            crafting_book_open,
            filtering_craftable,
        };

        Self::UnlockRecipes(unlock_recipes)
    }

    pub fn entity_destroy() -> Self {
        Self::EntityDestroy
    }

    pub fn remove_entity_effect(entity_id: i32, effect_id: i8) -> Self {
        let remove_entity_effect = RemoveEntityEffect {
            entity_id,
            effect_id,
        };

        Self::RemoveEntityEffect(remove_entity_effect)
    }

    pub fn resource_pack_send(url: String, hash: String) -> Self {
        let resource_pack_send = ResourcePackSend { url, hash };

        Self::ResourcePackSend(resource_pack_send)
    }

    pub fn respawn(dimension: i32, difficulty: u8, gamemode: u8, level_type: String) -> Self {
        let respawn = Respawn {
            dimension,
            difficulty,
            gamemode,
            level_type,
        };

        Self::Respawn(respawn)
    }

    pub fn entity_head_rotation(entity_id: i32, head_yaw: i8) -> Self {
        let entity_head_rotation = EntityHeadRotation {
            entity_id,
            head_yaw,
        };

        Self::EntityHeadRotation(entity_head_rotation)
    }

    pub fn world_border(action: i32) -> Self {
        let world_border = WorldBorder { action };

        Self::WorldBorder(world_border)
    }

    pub fn camera(camera_id: i32) -> Self {
        let camera = Camera { camera_id };

        Self::Camera(camera)
    }

    pub fn client_bound_held_item_slot(slot: i8) -> Self {
        let client_bound_held_item_slot = ClientBoundHeldItemSlot { slot };

        Self::ClientBoundHeldItemSlot(client_bound_held_item_slot)
    }

    pub fn scoreboard_display_objective(position: i8, name: String) -> Self {
        let scoreboard_display_objective = ScoreboardDisplayObjective { position, name };

        Self::ScoreboardDisplayObjective(scoreboard_display_objective)
    }

    pub fn entity_metadata(entity_id: i32, metadata: Metadata) -> Self {
        let entity_metadata = EntityMetadata {
            entity_id,
            metadata,
        };

        Self::EntityMetadata(entity_metadata)
    }

    pub fn attach_entity(entity_id: i32, vehicle_id: i32) -> Self {
        let attach_entity = AttachEntity {
            entity_id,
            vehicle_id,
        };

        Self::AttachEntity(attach_entity)
    }

    pub fn entity_velocity(
        entity_id: i32,
        velocity_x: i16,
        velocity_y: i16,
        velocity_z: i16,
    ) -> Self {
        let entity_velocity = EntityVelocity {
            entity_id,
            velocity_x,
            velocity_y,
            velocity_z,
        };

        Self::EntityVelocity(entity_velocity)
    }

    pub fn entity_equipment(entity_id: i32, slot: i32, item: Option<Slot>) -> Self {
        let entity_equipment = EntityEquipment {
            entity_id,
            slot,
            item,
        };

        Self::EntityEquipment(entity_equipment)
    }

    pub fn experience(experience_bar: f32, level: i32, total_experience: i32) -> Self {
        let experience = Experience {
            experience_bar,
            level,
            total_experience,
        };

        Self::Experience(experience)
    }

    pub fn update_health(health: f32, food: i32, food_saturation: f32) -> Self {
        let update_health = UpdateHealth {
            health,
            food,
            food_saturation,
        };

        Self::UpdateHealth(update_health)
    }

    pub fn scoreboard_objective(name: String, action: i8) -> Self {
        let scoreboard_objective = ScoreboardObjective { name, action };

        Self::ScoreboardObjective(scoreboard_objective)
    }

    pub fn set_passengers(entity_id: i32) -> Self {
        let set_passengers = SetPassengers { entity_id };

        Self::SetPassengers(set_passengers)
    }

    pub fn teams(team: String, mode: i8) -> Self {
        let teams = Teams { team, mode };

        Self::Teams(teams)
    }

    pub fn scoreboard_score(item_name: String, action: i8, score_name: String) -> Self {
        let scoreboard_score = ScoreboardScore {
            item_name,
            action,
            score_name,
        };

        Self::ScoreboardScore(scoreboard_score)
    }

    pub fn spawn_position(location: Position) -> Self {
        let spawn_position = SpawnPosition { location };

        Self::SpawnPosition(spawn_position)
    }

    pub fn update_time(age: i64, time: i64) -> Self {
        let update_time = UpdateTime { age, time };

        Self::UpdateTime(update_time)
    }

    pub fn title(action: i32) -> Self {
        let title = Title { action };

        Self::Title(title)
    }

    pub fn sound_effect(
        sound_id: i32,
        sound_category: i32,
        x: i32,
        y: i32,
        z: i32,
        volume: f32,
        pitch: f32,
    ) -> Self {
        let sound_effect = SoundEffect {
            sound_id,
            sound_category,
            x,
            y,
            z,
            volume,
            pitch,
        };

        Self::SoundEffect(sound_effect)
    }

    pub fn playerlist_header(header: String, footer: String) -> Self {
        let playerlist_header = PlayerlistHeader { header, footer };

        Self::PlayerlistHeader(playerlist_header)
    }

    pub fn collect(
        collected_entity_id: i32,
        collector_entity_id: i32,
        pickup_item_count: i32,
    ) -> Self {
        let collect = Collect {
            collected_entity_id,
            collector_entity_id,
            pickup_item_count,
        };

        Self::Collect(collect)
    }

    pub fn entity_teleport(
        entity_id: i32,
        x: f64,
        y: f64,
        z: f64,
        yaw: i8,
        pitch: i8,
        on_ground: bool,
    ) -> Self {
        let entity_teleport = EntityTeleport {
            entity_id,
            x,
            y,
            z,
            yaw,
            pitch,
            on_ground,
        };

        Self::EntityTeleport(entity_teleport)
    }

    pub fn entity_update_attributes(entity_id: i32) -> Self {
        let entity_update_attributes = EntityUpdateAttributes { entity_id };

        Self::EntityUpdateAttributes(entity_update_attributes)
    }

    pub fn entity_effect(
        entity_id: i32,
        effect_id: i8,
        amplifier: i8,
        duration: i32,
        hide_particles: i8,
    ) -> Self {
        let entity_effect = EntityEffect {
            entity_id,
            effect_id,
            amplifier,
            duration,
            hide_particles,
        };

        Self::EntityEffect(entity_effect)
    }

    pub fn select_advancement_tab(id: String) -> Self {
        let select_advancement_tab = SelectAdvancementTab { id };

        Self::SelectAdvancementTab(select_advancement_tab)
    }
}

#[derive(Packet, Debug)]
pub struct TeleportConfirm {
    #[packet(with = "var_int")]
    pub teleport_id: i32,
}

#[derive(Packet, Debug)]
pub struct ServerBoundTabComplete {
    pub text: String,
    pub assume_command: bool,
    pub looked_at_block: Position,
}

#[derive(Packet, Debug)]
pub struct ServerBoundChat {
    pub message: String,
}

#[derive(Packet, Debug)]
pub struct ClientCommand {
    #[packet(with = "var_int")]
    pub action_id: i32,
}

#[derive(Packet, Debug)]
pub struct Settings {
    pub locale: String,
    pub view_distance: i8,
    #[packet(with = "var_int")]
    pub chat_flags: i32,
    pub chat_colors: bool,
    pub skin_parts: u8,
    #[packet(with = "var_int")]
    pub main_hand: i32,
}

#[derive(Packet, Debug)]
pub struct ServerBoundTransaction {
    pub window_id: i8,
    pub action: i16,
    pub accepted: bool,
}

#[derive(Packet, Debug)]
pub struct EnchantItem {
    pub window_id: i8,
    pub enchantment: i8,
}

#[derive(Packet, Debug)]
pub struct WindowClick {
    pub window_id: u8,
    pub slot: i16,
    pub mouse_button: i8,
    pub action: i16,
    pub mode: i8,
    pub item: Option<Slot>,
}

#[derive(Packet, Debug)]
pub struct ServerBoundCloseWindow {
    pub window_id: u8,
}

#[derive(Packet, Debug)]
pub struct ServerBoundCustomPayload {
    pub channel: String,
    #[packet(with = "rest")]
    pub data: Vec<u8>,
}

#[derive(Packet, Debug)]
pub struct UseEntity {
    #[packet(with = "var_int")]
    pub target: i32,
    #[packet(with = "var_int")]
    pub mouse: i32,
}

#[derive(Packet, Debug)]
pub struct ServerBoundKeepAlive {
    #[packet(with = "var_int")]
    pub keep_alive_id: i32,
}

#[derive(Packet, Debug)]
pub struct ServerBoundPosition {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub on_ground: bool,
}

#[derive(Packet, Debug)]
pub struct PositionLook {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub yaw: f32,
    pub pitch: f32,
    pub on_ground: bool,
}

#[derive(Packet, Debug)]
pub struct Look {
    pub yaw: f32,
    pub pitch: f32,
    pub on_ground: bool,
}

#[derive(Packet, Debug)]
pub struct Flying {
    pub on_ground: bool,
}

#[derive(Packet, Debug)]
pub struct ServerBoundVehicleMove {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub yaw: f32,
    pub pitch: f32,
}

#[derive(Packet, Debug)]
pub struct SteerBoat {
    pub left_paddle: bool,
    pub right_paddle: bool,
}

#[derive(Packet, Debug)]
pub struct CraftRecipeRequest {
    pub window_id: i8,
    #[packet(with = "var_int")]
    pub recipe: i32,
    pub make_all: bool,
}

#[derive(Packet, Debug)]
pub struct ServerBoundAbilities {
    pub flags: i8,
    pub flying_speed: f32,
    pub walking_speed: f32,
}

#[derive(Packet, Debug)]
pub struct BlockDig {
    pub status: i8,
    pub location: Position,
    pub face: i8,
}

#[derive(Packet, Debug)]
pub struct EntityAction {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    #[packet(with = "var_int")]
    pub action_id: i32,
    #[packet(with = "var_int")]
    pub jump_boost: i32,
}

#[derive(Packet, Debug)]
pub struct SteerVehicle {
    pub sideways: f32,
    pub forward: f32,
    pub jump: u8,
}

#[derive(Packet, Debug)]
pub struct CraftingBookData {
    #[packet(with = "var_int")]
    pub type_: i32,
}

#[derive(Packet, Debug)]
pub struct ResourcePackReceive {
    #[packet(with = "var_int")]
    pub result: i32,
}

#[derive(Packet, Debug)]
pub struct ServerBoundHeldItemSlot {
    pub slot_id: i16,
}

#[derive(Packet, Debug)]
pub struct SetCreativeSlot {
    pub slot: i16,
    pub item: Option<Slot>,
}

#[derive(Packet, Debug)]
pub struct UpdateSign {
    pub location: Position,
    pub text1: String,
    pub text2: String,
    pub text3: String,
    pub text4: String,
}

#[derive(Packet, Debug)]
pub struct ArmAnimation {
    #[packet(with = "var_int")]
    pub hand: i32,
}

#[derive(Packet, Debug)]
pub struct Spectate {
    pub target: Uuid,
}

#[derive(Packet, Debug)]
pub struct BlockPlace {
    pub location: Position,
    #[packet(with = "var_int")]
    pub direction: i32,
    #[packet(with = "var_int")]
    pub hand: i32,
    pub cursor_x: f32,
    pub cursor_y: f32,
    pub cursor_z: f32,
}

#[derive(Packet, Debug)]
pub struct UseItem {
    #[packet(with = "var_int")]
    pub hand: i32,
}

#[derive(Packet, Debug)]
pub struct AdvancementTab {
    #[packet(with = "var_int")]
    pub action: i32,
}

#[derive(Packet, Debug)]
pub struct SpawnEntity {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub object_uuid: Uuid,
    pub type_: i8,
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub pitch: i8,
    pub yaw: i8,
    pub object_data: i32,
    pub velocity_x: i16,
    pub velocity_y: i16,
    pub velocity_z: i16,
}

#[derive(Packet, Debug)]
pub struct SpawnEntityExperienceOrb {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub count: i16,
}

#[derive(Packet, Debug)]
pub struct SpawnEntityWeather {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub type_: i8,
    pub x: f64,
    pub y: f64,
    pub z: f64,
}

#[derive(Packet, Debug)]
pub struct SpawnEntityLiving {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub entity_uuid: Uuid,
    #[packet(with = "var_int")]
    pub type_: i32,
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub yaw: i8,
    pub pitch: i8,
    pub head_pitch: i8,
    pub velocity_x: i16,
    pub velocity_y: i16,
    pub velocity_z: i16,
    pub metadata: Metadata,
}

#[derive(Packet, Debug)]
pub struct SpawnEntityPainting {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub entity_uuid: Uuid,
    pub title: String,
    pub location: Position,
    pub direction: u8,
}

#[derive(Packet, Debug)]
pub struct NamedEntitySpawn {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub player_uuid: Uuid,
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub yaw: i8,
    pub pitch: i8,
    pub metadata: Metadata,
}

#[derive(Packet, Debug)]
pub struct Animation {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub animation: u8,
}

#[derive(Packet, Debug)]
pub struct Advancements {
    pub reset: bool,
}

#[derive(Packet, Debug)]
pub struct BlockBreakAnimation {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub location: Position,
    pub destroy_stage: i8,
}

#[derive(Packet, Debug)]
pub struct TileEntityData {
    pub location: Position,
    pub action: u8,
    pub nbt_data: CompoundTag,
}

#[derive(Packet, Debug)]
pub struct BlockAction {
    pub location: Position,
    pub byte1: u8,
    pub byte2: u8,
    #[packet(with = "var_int")]
    pub block_id: i32,
}

#[derive(Packet, Debug)]
pub struct BlockChange {
    pub location: Position,
    #[packet(with = "var_int")]
    pub type_: i32,
}

#[derive(Packet, Debug)]
pub struct BossBar {
    pub entity_uuid: Uuid,
    #[packet(with = "var_int")]
    pub action: i32,
}

#[derive(Packet, Debug)]
pub struct Difficulty {
    pub difficulty: u8,
}

#[derive(Packet, Debug)]
pub struct ClientBoundChat {
    pub message: String,
    pub position: i8,
}

#[derive(Packet, Debug)]
pub struct MultiBlockChange {
    pub chunk_x: i32,
    pub chunk_z: i32,
}

#[derive(Packet, Debug)]
pub struct ClientBoundTransaction {
    pub window_id: i8,
    pub action: i16,
    pub accepted: bool,
}

#[derive(Packet, Debug)]
pub struct ClientBoundCloseWindow {
    pub window_id: u8,
}

#[derive(Packet, Debug)]
pub struct OpenWindow {
    pub window_id: u8,
    pub inventory_type: String,
    pub window_title: String,
    pub slot_count: u8,
}

#[derive(Packet, Debug)]
pub struct WindowItems {
    pub window_id: u8,
}

#[derive(Packet, Debug)]
pub struct CraftProgressBar {
    pub window_id: u8,
    pub property: i16,
    pub value: i16,
}

#[derive(Packet, Debug)]
pub struct SetSlot {
    pub window_id: i8,
    pub slot: i16,
    pub item: Option<Slot>,
}

#[derive(Packet, Debug)]
pub struct SetCooldown {
    #[packet(with = "var_int")]
    pub item_id: i32,
    #[packet(with = "var_int")]
    pub cooldown_ticks: i32,
}

#[derive(Packet, Debug)]
pub struct ClientBoundCustomPayload {
    pub channel: String,
    #[packet(with = "rest")]
    pub data: Vec<u8>,
}

#[derive(Packet, Debug)]
pub struct NamedSoundEffect {
    pub sound_name: String,
    #[packet(with = "var_int")]
    pub sound_category: i32,
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub volume: f32,
    pub pitch: f32,
}

#[derive(Packet, Debug)]
pub struct KickDisconnect {
    pub reason: String,
}

#[derive(Packet, Debug)]
pub struct EntityStatus {
    pub entity_id: i32,
    pub entity_status: i8,
}

#[derive(Packet, Debug)]
pub struct Explosion {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub radius: f32,
    pub player_motion_x: f32,
    pub player_motion_y: f32,
    pub player_motion_z: f32,
}

#[derive(Packet, Debug)]
pub struct UnloadChunk {
    pub chunk_x: i32,
    pub chunk_z: i32,
}

#[derive(Packet, Debug)]
pub struct GameStateChange {
    pub reason: u8,
    pub game_mode: f32,
}

#[derive(Packet, Debug)]
pub struct ClientBoundKeepAlive {
    #[packet(with = "var_int")]
    pub keep_alive_id: i32,
}

#[derive(Packet, Debug)]
pub struct MapChunk {
    pub x: i32,
    pub z: i32,
    pub ground_up: bool,
    #[packet(with = "var_int")]
    pub bit_map: i32,
    pub chunk_data: Vec<u8>,
}

#[derive(Packet, Debug)]
pub struct WorldEvent {
    pub effect_id: i32,
    pub location: Position,
    pub data: i32,
    pub global: bool,
}

#[derive(Packet, Debug)]
pub struct WorldParticles {
    pub particle_id: i32,
    pub long_distance: bool,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub offset_x: f32,
    pub offset_y: f32,
    pub offset_z: f32,
    pub particle_data: f32,
    pub particles: i32,
}

#[derive(Packet, Debug)]
pub struct JoinGame {
    pub entity_id: i32,
    pub game_mode: u8,
    pub dimension: i32,
    pub difficulty: u8,
    pub max_players: u8,
    pub level_type: String,
    pub reduced_debug_info: bool,
}

#[derive(Packet, Debug)]
pub struct Map {
    #[packet(with = "var_int")]
    pub item_damage: i32,
    pub scale: i8,
    pub tracking_position: bool,
    pub columns: i8,
}

#[derive(Packet, Debug)]
pub struct RelEntityMove {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub d_x: i16,
    pub d_y: i16,
    pub d_z: i16,
    pub on_ground: bool,
}

#[derive(Packet, Debug)]
pub struct EntityMoveLook {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub d_x: i16,
    pub d_y: i16,
    pub d_z: i16,
    pub yaw: i8,
    pub pitch: i8,
    pub on_ground: bool,
}

#[derive(Packet, Debug)]
pub struct EntityLook {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub yaw: i8,
    pub pitch: i8,
    pub on_ground: bool,
}

#[derive(Packet, Debug)]
pub struct Entity {
    #[packet(with = "var_int")]
    pub entity_id: i32,
}

#[derive(Packet, Debug)]
pub struct ClientBoundVehicleMove {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub yaw: f32,
    pub pitch: f32,
}

#[derive(Packet, Debug)]
pub struct OpenSignEntity {
    pub location: Position,
}

#[derive(Packet, Debug)]
pub struct CraftRecipeResponse {
    pub window_id: i8,
    #[packet(with = "var_int")]
    pub recipe: i32,
}

#[derive(Packet, Debug)]
pub struct ClientBoundAbilities {
    pub flags: i8,
    pub flying_speed: f32,
    pub walking_speed: f32,
}

#[derive(Packet, Debug)]
pub struct CombatEvent {
    #[packet(with = "var_int")]
    pub event: i32,
}

#[derive(Packet, Debug)]
pub struct PlayerInfo {
    #[packet(with = "var_int")]
    pub action: i32,
}

#[derive(Packet, Debug)]
pub struct ClientBoundPosition {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub yaw: f32,
    pub pitch: f32,
    pub flags: i8,
    #[packet(with = "var_int")]
    pub teleport_id: i32,
}

#[derive(Packet, Debug)]
pub struct Bed {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub location: Position,
}

#[derive(Packet, Debug)]
pub struct UnlockRecipes {
    #[packet(with = "var_int")]
    pub action: i32,
    pub crafting_book_open: bool,
    pub filtering_craftable: bool,
}

#[derive(Packet, Debug)]
pub struct RemoveEntityEffect {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub effect_id: i8,
}

#[derive(Packet, Debug)]
pub struct ResourcePackSend {
    pub url: String,
    pub hash: String,
}

#[derive(Packet, Debug)]
pub struct Respawn {
    pub dimension: i32,
    pub difficulty: u8,
    pub gamemode: u8,
    pub level_type: String,
}

#[derive(Packet, Debug)]
pub struct EntityHeadRotation {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub head_yaw: i8,
}

#[derive(Packet, Debug)]
pub struct WorldBorder {
    #[packet(with = "var_int")]
    pub action: i32,
}

#[derive(Packet, Debug)]
pub struct Camera {
    #[packet(with = "var_int")]
    pub camera_id: i32,
}

#[derive(Packet, Debug)]
pub struct ClientBoundHeldItemSlot {
    pub slot: i8,
}

#[derive(Packet, Debug)]
pub struct ScoreboardDisplayObjective {
    pub position: i8,
    pub name: String,
}

#[derive(Packet, Debug)]
pub struct EntityMetadata {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub metadata: Metadata,
}

#[derive(Packet, Debug)]
pub struct AttachEntity {
    pub entity_id: i32,
    pub vehicle_id: i32,
}

#[derive(Packet, Debug)]
pub struct EntityVelocity {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub velocity_x: i16,
    pub velocity_y: i16,
    pub velocity_z: i16,
}

#[derive(Packet, Debug)]
pub struct EntityEquipment {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    #[packet(with = "var_int")]
    pub slot: i32,
    pub item: Option<Slot>,
}

#[derive(Packet, Debug)]
pub struct Experience {
    pub experience_bar: f32,
    #[packet(with = "var_int")]
    pub level: i32,
    #[packet(with = "var_int")]
    pub total_experience: i32,
}

#[derive(Packet, Debug)]
pub struct UpdateHealth {
    pub health: f32,
    #[packet(with = "var_int")]
    pub food: i32,
    pub food_saturation: f32,
}

#[derive(Packet, Debug)]
pub struct ScoreboardObjective {
    pub name: String,
    pub action: i8,
}

#[derive(Packet, Debug)]
pub struct SetPassengers {
    #[packet(with = "var_int")]
    pub entity_id: i32,
}

#[derive(Packet, Debug)]
pub struct Teams {
    pub team: String,
    pub mode: i8,
}

#[derive(Packet, Debug)]
pub struct ScoreboardScore {
    pub item_name: String,
    pub action: i8,
    pub score_name: String,
}

#[derive(Packet, Debug)]
pub struct SpawnPosition {
    pub location: Position,
}

#[derive(Packet, Debug)]
pub struct UpdateTime {
    pub age: i64,
    pub time: i64,
}

#[derive(Packet, Debug)]
pub struct Title {
    #[packet(with = "var_int")]
    pub action: i32,
}

#[derive(Packet, Debug)]
pub struct SoundEffect {
    #[packet(with = "var_int")]
    pub sound_id: i32,
    #[packet(with = "var_int")]
    pub sound_category: i32,
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub volume: f32,
    pub pitch: f32,
}

#[derive(Packet, Debug)]
pub struct PlayerlistHeader {
    pub header: String,
    pub footer: String,
}

#[derive(Packet, Debug)]
pub struct Collect {
    #[packet(with = "var_int")]
    pub collected_entity_id: i32,
    #[packet(with = "var_int")]
    pub collector_entity_id: i32,
    #[packet(with = "var_int")]
    pub pickup_item_count: i32,
}

#[derive(Packet, Debug)]
pub struct EntityTeleport {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub yaw: i8,
    pub pitch: i8,
    pub on_ground: bool,
}

#[derive(Packet, Debug)]
pub struct EntityUpdateAttributes {
    #[packet(with = "var_int")]
    pub entity_id: i32,
}

#[derive(Packet, Debug)]
pub struct EntityEffect {
    #[packet(with = "var_int")]
    pub entity_id: i32,
    pub effect_id: i8,
    pub amplifier: i8,
    #[packet(with = "var_int")]
    pub duration: i32,
    pub hide_particles: i8,
}

#[derive(Packet, Debug)]
pub struct SelectAdvancementTab {
    pub id: String,
}
